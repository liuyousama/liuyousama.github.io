<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liuyousama.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本篇文章为Kingfisher源码导读，不会详细分析源码中的每一个细节，只是分享我阅读源码时的顺序以及思路，按照文中的代码阅读顺序加上你自己主动阅读源码的一些理解，读懂整个Kingfisher系统内部的工作原理应该不是很难的事情。 SourceSource表示一个图片资源的来源。KF中图片拥有两种来源，一个是来源于网络(network)，一个是来源于本地(provider)">
<meta property="og:type" content="article">
<meta property="og:title" content="Kingfisher源码阅读">
<meta property="og:url" content="https://liuyousama.top/2020/10/18/Kingfisher%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.html">
<meta property="og:site_name" content="六游的博客小站">
<meta property="og:description" content="本篇文章为Kingfisher源码导读，不会详细分析源码中的每一个细节，只是分享我阅读源码时的顺序以及思路，按照文中的代码阅读顺序加上你自己主动阅读源码的一些理解，读懂整个Kingfisher系统内部的工作原理应该不是很难的事情。 SourceSource表示一个图片资源的来源。KF中图片拥有两种来源，一个是来源于网络(network)，一个是来源于本地(provider)">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-10-17T17:26:22.000Z">
<meta property="article:modified_time" content="2024-08-27T17:29:08.335Z">
<meta property="article:author" content="六游">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://liuyousama.top/2020/10/18/Kingfisher%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Kingfisher源码阅读 | 六游的博客小站</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">六游的博客小站</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuyousama.top/2020/10/18/Kingfisher%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="六游">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="六游的博客小站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kingfisher源码阅读
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-18 01:26:22" itemprop="dateCreated datePublished" datetime="2020-10-18T01:26:22+08:00">2020-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-28 01:29:08" itemprop="dateModified" datetime="2024-08-28T01:29:08+08:00">2024-08-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本篇文章为Kingfisher源码导读，不会详细分析源码中的每一个细节，只是分享我阅读源码时的顺序以及思路，按照文中的代码阅读顺序加上你自己主动阅读源码的一些理解，读懂整个Kingfisher系统内部的工作原理应该不是很难的事情。</p>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>Source表示一个图片资源的来源。KF中图片拥有两种来源，一个是来源于网络(network)，一个是来源于本地(provider)</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Source</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> network(<span class="type">Resource</span>)</span><br><span class="line">    <span class="keyword">case</span> provider(<span class="type">ImageDataProvider</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> cacheKey: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .network(<span class="keyword">let</span> resource): <span class="keyword">return</span> resource.cacheKey</span><br><span class="line">        <span class="keyword">case</span> .provider(<span class="keyword">let</span> provider): <span class="keyword">return</span> provider.cacheKey</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> url: <span class="type">URL</span>? &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .network(<span class="keyword">let</span> resource): <span class="keyword">return</span> resource.downloadURL</span><br><span class="line">        <span class="keyword">case</span> .provider(<span class="keyword">let</span> provider): <span class="keyword">return</span> provider.contentURL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Resource与ImageDataProvider是两个协议类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line">    <span class="comment">// 用于缓存的键</span></span><br><span class="line">    <span class="keyword">var</span> cacheKey: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">// 目标图片的网址</span></span><br><span class="line">    <span class="keyword">var</span> downloadURL: <span class="type">URL</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">convertToSource</span>() -&gt; <span class="type">Source</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> downloadURL.isFileURL <span class="operator">?</span></span><br><span class="line">        .provider(<span class="type">LocalFileImageDataProvider</span>(fileURL: downloadURL, cacheKey: cacheKey)) :</span><br><span class="line">        .network(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">ImageDataProvider</span> &#123;</span><br><span class="line">    <span class="comment">// 用于缓存的键</span></span><br><span class="line">    <span class="keyword">var</span> cacheKey: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">// 用于外部读取文件资源的方法</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">data</span>(<span class="params">handler</span>: <span class="keyword">@escaping</span> (<span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span>)</span><br><span class="line">    <span class="comment">// URL</span></span><br><span class="line">    <span class="keyword">var</span> contentURL: <span class="type">URL</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完了协议类型，再来看对应的两个实现会更加容易理解一些</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个是我们日常使用中最常用到的，直接使用URL作为参数来加载一个网络图片</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">URL</span>: <span class="title class_ inherited__">Resource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> cacheKey: <span class="type">String</span> &#123; <span class="keyword">return</span> absoluteString &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> downloadURL: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二个是实现了ImageDataProvider协议的本地图片加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">LocalFileImageDataProvider</span>: <span class="title class_ inherited__">ImageDataProvider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> fileURL: <span class="type">URL</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> cacheKey: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">fileURL</span>: <span class="type">URL</span>, <span class="params">cacheKey</span>: <span class="type">String</span>? <span class="operator">=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fileURL <span class="operator">=</span> fileURL</span><br><span class="line">        <span class="keyword">self</span>.cacheKey <span class="operator">=</span> cacheKey <span class="operator">??</span> fileURL.absoluteString</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// data方法很简单，就是直接读取对应路径的文件，并将读取的结果通过闭包回调出去</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">data</span>(<span class="params">handler</span>: (<span class="type">Result</span>&lt;<span class="type">Data</span>, <span class="type">Error</span>&gt;) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        handler(<span class="type">Result</span>(catching: &#123; <span class="keyword">try</span> <span class="type">Data</span>(contentsOf: fileURL) &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> contentURL: <span class="type">URL</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> fileURL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>为了能够满足跨平台的需求，KF定义了一系列类型别名，并且结合条件编译指令，在不同的平台上为这一系列类型别名绑定不同的类型。是非常值得学习的一个做法。此次源码分析我们以iOS平台为例，在iOS平台中这些类型别名存在以下对应关系</p>
<p>KFCrossPlatformImage -&gt; UIImage</p>
<p>KFCrossPlatformColor -&gt; UIColor</p>
<p>KFCrossPlatformImageView -&gt; UIImageView</p>
<p>KFCrossPlatformView -&gt; UIView</p>
<p>KFCrossPlatformButton -&gt; UIButton</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">#if</span> os(macOS)</span><br><span class="line"><span class="keyword">import</span> AppKit</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">KFCrossPlatformImage</span> <span class="operator">=</span> <span class="type">NSImage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">KFCrossPlatformView</span> <span class="operator">=</span> <span class="type">NSView</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">KFCrossPlatformColor</span> <span class="operator">=</span> <span class="type">NSColor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">KFCrossPlatformImageView</span> <span class="operator">=</span> <span class="type">NSImageView</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">KFCrossPlatformButton</span> <span class="operator">=</span> <span class="type">NSButton</span></span><br><span class="line"><span class="keyword">#else</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">KFCrossPlatformImage</span> <span class="operator">=</span> <span class="type">UIImage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">KFCrossPlatformColor</span> <span class="operator">=</span> <span class="type">UIColor</span></span><br><span class="line"><span class="keyword">#if</span> <span class="operator">!</span>os(watchOS)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">KFCrossPlatformImageView</span> <span class="operator">=</span> <span class="type">UIImageView</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">KFCrossPlatformView</span> <span class="operator">=</span> <span class="type">UIView</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">KFCrossPlatformButton</span> <span class="operator">=</span> <span class="type">UIButton</span></span><br><span class="line"><span class="keyword">#else</span></span><br><span class="line"><span class="keyword">import</span> WatchKit</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line"><span class="keyword">#endif</span></span><br></pre></td></tr></table></figure>

<p>接着就是入口的代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.首先是定义了个空协议</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">KingfisherCompatible</span>: <span class="title class_ inherited__">AnyObject</span> &#123; &#125;</span><br><span class="line"><span class="comment">// 2.然后让之前我们提到过的类型别名都实现这个空协议</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">KFCrossPlatformImage</span>: <span class="title class_ inherited__">KingfisherCompatible</span> &#123; &#125;</span><br><span class="line"><span class="keyword">#if</span> <span class="operator">!</span>os(watchOS)</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">KFCrossPlatformImageView</span>: <span class="title class_ inherited__">KingfisherCompatible</span> &#123; &#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">KFCrossPlatformButton</span>: <span class="title class_ inherited__">KingfisherCompatible</span> &#123; &#125;</span><br><span class="line"><span class="keyword">#else</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">WKInterfaceImage</span>: <span class="title class_ inherited__">KingfisherCompatible</span> &#123; &#125;</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line"><span class="comment">// 3.之后给这个空协议添加了个扩展</span></span><br><span class="line"><span class="comment">// 给协议添加扩展就等于给上面那些实现协议的类型添加扩展所以这三个步骤的整体结果就是：</span></span><br><span class="line"><span class="comment">// 给所有需要的类型添加了一个统一的扩展</span></span><br><span class="line"><span class="comment">// 扩展中提供了kf计算属性，在get中返回了一个KingfisherWrapper对象</span></span><br><span class="line"><span class="comment">// 这就是我们平时使用xxx.kf.setImage的奥秘所在</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">KingfisherCompatible</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> kf: <span class="type">KingfisherWrapper</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">KingfisherWrapper</span>(<span class="keyword">self</span>) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. kf计算属性返回的KingfisherWrapper对象十分简单</span></span><br><span class="line"><span class="comment">// 就是对原对象的简单封装</span></span><br><span class="line"><span class="comment">// 如果我们是对UIImageView调用kf获取到的KingfisherWrapper对象，那么其中的base属性就是UIImageView对象本身</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">KingfisherWrapper</span>&lt;<span class="type">Base</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> base: <span class="type">Base</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">base</span>: <span class="type">Base</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.base <span class="operator">=</span> base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kf计算属性返回的KingfisherWrapper只是一个简单的包装器，本身不存储任何状态，并且在使用过后就会立即销毁，那么它是怎么完成那么复杂的操作（图片的下载，缓存，加载）的呢？其实KingfisherWrapper在工作的过程中是可以拿到一些持久存储的状态信息的，Kingfisher直接将一些状态以关联属性的方式存储在特定的Base中了，这里我们以UIImageView为例</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关联属性存储时需要用到的Key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> taskIdentifierKey: <span class="type">Void</span>?</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> indicatorKey: <span class="type">Void</span>?</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> indicatorTypeKey: <span class="type">Void</span>?</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> placeholderKey: <span class="type">Void</span>?</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> imageTaskKey: <span class="type">Void</span>?</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">KingfisherWrapper</span> <span class="keyword">where</span> <span class="type">Base</span>: <span class="type">KFCrossPlatformImageView</span> &#123;</span><br><span class="line">	<span class="comment">// 存储当前图片下载任务的ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private(set)</span> <span class="keyword">var</span> taskIdentifier: <span class="type">Source</span>.<span class="type">Identifier</span>.<span class="type">Value</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> box: <span class="type">Box</span>&lt;<span class="type">Source</span>.<span class="type">Identifier</span>.<span class="type">Value</span>&gt;? <span class="operator">=</span> getAssociatedObject(base, <span class="operator">&amp;</span>taskIdentifierKey)</span><br><span class="line">            <span class="keyword">return</span> box<span class="operator">?</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> box <span class="operator">=</span> newValue.map &#123; <span class="type">Box</span>(<span class="variable">$0</span>) &#125;</span><br><span class="line">            setRetainedAssociatedObject(base, <span class="operator">&amp;</span>taskIdentifierKey, box)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KF允许你为还未加载完成的图片提供一个指示器</span></span><br><span class="line">    <span class="comment">// 这个指示器有多种类型，该属性就是存储该UIImageView所使用的的指示器类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> indicatorType: <span class="type">IndicatorType</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getAssociatedObject(base, <span class="operator">&amp;</span>indicatorTypeKey) <span class="operator">??</span> .none</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> newValue &#123;</span><br><span class="line">            <span class="keyword">case</span> .none: indicator <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">case</span> .activity: indicator <span class="operator">=</span> <span class="type">ActivityIndicator</span>()</span><br><span class="line">            <span class="keyword">case</span> .image(<span class="keyword">let</span> data): indicator <span class="operator">=</span> <span class="type">ImageIndicator</span>(imageData: data)</span><br><span class="line">            <span class="keyword">case</span> .custom(<span class="keyword">let</span> anIndicator): indicator <span class="operator">=</span> anIndicator</span><br><span class="line">            &#125;</span><br><span class="line">            setRetainedAssociatedObject(base, <span class="operator">&amp;</span>indicatorTypeKey, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果你指定了指示器类型为自定义指示器，那么可以通过该属性存储该UIImageView所使用的自定义指示器对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private(set)</span> <span class="keyword">var</span> indicator: <span class="type">Indicator</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> box: <span class="type">Box</span>&lt;<span class="type">Indicator</span>&gt;? <span class="operator">=</span> getAssociatedObject(base, <span class="operator">&amp;</span>indicatorKey)</span><br><span class="line">            <span class="keyword">return</span> box<span class="operator">?</span>.value</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// Remove previous</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> previousIndicator <span class="operator">=</span> indicator &#123;</span><br><span class="line">                previousIndicator.view.removeFromSuperview()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newIndicator <span class="operator">=</span> newValue &#123;</span><br><span class="line">                <span class="keyword">let</span> view <span class="operator">=</span> newIndicator.view</span><br><span class="line">                </span><br><span class="line">                base.addSubview(view)</span><br><span class="line">                view.translatesAutoresizingMaskIntoConstraints <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">                view.centerXAnchor.constraint(</span><br><span class="line">                    equalTo: base.centerXAnchor, constant: newIndicator.centerOffset.x).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                view.centerYAnchor.constraint(</span><br><span class="line">                    equalTo: base.centerYAnchor, constant: newIndicator.centerOffset.y).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> newIndicator.sizeStrategy(in: base) &#123;</span><br><span class="line">                <span class="keyword">case</span> .intrinsicSize:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">case</span> .full:</span><br><span class="line">                    view.heightAnchor.constraint(equalTo: base.heightAnchor, constant: <span class="number">0</span>).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                    view.widthAnchor.constraint(equalTo: base.widthAnchor, constant: <span class="number">0</span>).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                <span class="keyword">case</span> .size(<span class="keyword">let</span> size):</span><br><span class="line">                    view.heightAnchor.constraint(equalToConstant: size.height).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                    view.widthAnchor.constraint(equalToConstant: size.width).isActive <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                newIndicator.view.isHidden <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            setRetainedAssociatedObject(base, <span class="operator">&amp;</span>indicatorKey, newValue.map(<span class="type">Box</span>.<span class="keyword">init</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前UIImageView之下的图片加载任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> imageTask: <span class="type">DownloadTask</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> getAssociatedObject(base, <span class="operator">&amp;</span>imageTaskKey) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; setRetainedAssociatedObject(base, <span class="operator">&amp;</span>imageTaskKey, newValue)&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当图片还未加载完毕或者图片加载失败的时候，KF允许你提供一个Placeholder来填充空白的UIImageView</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private(set)</span> <span class="keyword">var</span> placeholder: <span class="type">Placeholder</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> getAssociatedObject(base, <span class="operator">&amp;</span>placeholderKey) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> previousPlaceholder <span class="operator">=</span> placeholder &#123;</span><br><span class="line">                previousPlaceholder.remove(from: base)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newPlaceholder <span class="operator">=</span> newValue &#123;</span><br><span class="line">                newPlaceholder.add(to: base)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                base.image <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            setRetainedAssociatedObject(base, <span class="operator">&amp;</span>placeholderKey, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着就是KingfisherWrapper中的核心方法<code>setImage</code>了。这里以UIImageView为例（<code>KFCrossPlatformImageView</code>即对应<code>UIImageView</code>）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">KingfisherWrapper</span> <span class="keyword">where</span> <span class="type">Base</span>: <span class="type">KFCrossPlatformImageView</span> &#123;</span><br><span class="line">    <span class="comment">// 传入网络类型的Resource作为图片资源来源，是日常中最常用的方式，即通过URL传入</span></span><br><span class="line">	<span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">setImage</span>(</span><br><span class="line">        <span class="params">with</span> <span class="params">resource</span>: <span class="type">Resource</span>?,</span><br><span class="line">        <span class="params">placeholder</span>: <span class="type">Placeholder</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">        <span class="params">options</span>: <span class="type">KingfisherOptionsInfo</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">        <span class="params">progressBlock</span>: <span class="type">DownloadProgressBlock</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">        <span class="params">completionHandler</span>: ((<span class="type">Result</span>&lt;<span class="type">RetrieveImageResult</span>, <span class="type">KingfisherError</span>&gt;) -&gt; <span class="type">Void</span>)<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">DownloadTask</span>?</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> setImage(</span><br><span class="line">            with: resource<span class="operator">?</span>.convertToSource(),</span><br><span class="line">            placeholder: placeholder,</span><br><span class="line">            options: options,</span><br><span class="line">            progressBlock: progressBlock,</span><br><span class="line">            completionHandler: completionHandler)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入本地类型的ImageDataProvider作为图片资源来源</span></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">setImage</span>(</span><br><span class="line">        <span class="params">with</span> <span class="params">provider</span>: <span class="type">ImageDataProvider</span>?,</span><br><span class="line">        <span class="params">placeholder</span>: <span class="type">Placeholder</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">        <span class="params">options</span>: <span class="type">KingfisherOptionsInfo</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">        <span class="params">progressBlock</span>: <span class="type">DownloadProgressBlock</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">        <span class="params">completionHandler</span>: ((<span class="type">Result</span>&lt;<span class="type">RetrieveImageResult</span>, <span class="type">KingfisherError</span>&gt;) -&gt; <span class="type">Void</span>)<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">DownloadTask</span>?</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> setImage(</span><br><span class="line">            with: provider.map &#123; .provider(<span class="variable">$0</span>) &#125;,</span><br><span class="line">            placeholder: placeholder,</span><br><span class="line">            options: options,</span><br><span class="line">            progressBlock: progressBlock,</span><br><span class="line">            completionHandler: completionHandler)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前面两个方法都是对于不同source类型的简易封装，其内部都调用了一个共同的核心方法</span></span><br><span class="line">    <span class="comment">// 就是下面这个setImage</span></span><br><span class="line">    <span class="keyword">@discardableResult</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">setImage</span>(</span><br><span class="line">        <span class="params">with</span> <span class="params">source</span>: <span class="type">Source</span>?,</span><br><span class="line">        <span class="params">placeholder</span>: <span class="type">Placeholder</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">        <span class="params">options</span>: <span class="type">KingfisherOptionsInfo</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">        <span class="params">progressBlock</span>: <span class="type">DownloadProgressBlock</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">        <span class="params">completionHandler</span>: ((<span class="type">Result</span>&lt;<span class="type">RetrieveImageResult</span>, <span class="type">KingfisherError</span>&gt;) -&gt; <span class="type">Void</span>)<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">DownloadTask</span>?</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> mutatingSelf <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line">        <span class="comment">// source判空，如果传入的source为nil，则视为图片加载失败</span></span><br><span class="line">        <span class="comment">// 设置placeholder，清理task，并调用completion通知错误</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> source <span class="operator">=</span> source <span class="keyword">else</span> &#123;</span><br><span class="line">            mutatingSelf.placeholder <span class="operator">=</span> placeholder</span><br><span class="line">            mutatingSelf.taskIdentifier <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            completionHandler<span class="operator">?</span>(.failure(<span class="type">KingfisherError</span>.imageSettingError(reason: .emptySource)))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 合并全局options与当前方法参数的options</span></span><br><span class="line">        <span class="keyword">var</span> options <span class="operator">=</span> <span class="type">KingfisherParsedOptionsInfo</span>(<span class="type">KingfisherManager</span>.shared.defaultOptions <span class="operator">+</span> (options <span class="operator">??</span> .empty))</span><br><span class="line">		<span class="comment">// 有两种情况直接更新当前的placeholder：</span></span><br><span class="line">        <span class="comment">// 第一种：options中设置为加载图片时并不需要保持当前图片</span></span><br><span class="line">        <span class="comment">// 第二种：当前UIImageView中既没有当前图片，也没有placeholder，处于一个空白的状态</span></span><br><span class="line">        <span class="keyword">let</span> isEmptyImage <span class="operator">=</span> base.image <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">&amp;&amp;</span> <span class="keyword">self</span>.placeholder <span class="operator">==</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>options.keepCurrentImageWhileLoading <span class="operator">||</span> isEmptyImage &#123;</span><br><span class="line">            mutatingSelf.placeholder <span class="operator">=</span> placeholder</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> maybeIndicator <span class="operator">=</span> indicator</span><br><span class="line">        maybeIndicator<span class="operator">?</span>.startAnimatingView()</span><br><span class="line">		<span class="comment">// 获取下一个全局自增的taskIdentifier</span></span><br><span class="line">        <span class="keyword">let</span> issuedIdentifier <span class="operator">=</span> <span class="type">Source</span>.<span class="type">Identifier</span>.next()</span><br><span class="line">        mutatingSelf.taskIdentifier <span class="operator">=</span> issuedIdentifier</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> base.shouldPreloadAllAnimation() &#123;</span><br><span class="line">            options.preloadAllAnimationData <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 如果参数中传入了progressBlock图片加载进度回调函数，那么将其合并到onDataReceived通知中去</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> block <span class="operator">=</span> progressBlock &#123;</span><br><span class="line">            options.onDataReceived <span class="operator">=</span> (options.onDataReceived <span class="operator">??</span> []) <span class="operator">+</span> [<span class="type">ImageLoadingProgressSideEffect</span>(block)]</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 负责监听图片数据加载，并对加载进来的数据进行解码，最后生成Image对象数据，并将生成的Image设为UIImageView的Image</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> provider <span class="operator">=</span> <span class="type">ImageProgressiveProvider</span>(options, refresh: &#123; image <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.base.image <span class="operator">=</span> image</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            options.onDataReceived <span class="operator">=</span> (options.onDataReceived <span class="operator">??</span> []) <span class="operator">+</span> [provider]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 猜测：判断数据的一致性，防止多线程带来的问题</span></span><br><span class="line">        options.onDataReceived<span class="operator">?</span>.forEach &#123;</span><br><span class="line">            <span class="variable">$0</span>.onShouldApply <span class="operator">=</span> &#123; issuedIdentifier <span class="operator">==</span> <span class="keyword">self</span>.taskIdentifier &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 通过KingfisherManager来生成图片加载的task</span></span><br><span class="line">        <span class="keyword">let</span> task <span class="operator">=</span> <span class="type">KingfisherManager</span>.shared.retrieveImage(</span><br><span class="line">            with: source,</span><br><span class="line">            options: options,</span><br><span class="line">            downloadTaskUpdated: &#123; mutatingSelf.imageTask <span class="operator">=</span> <span class="variable">$0</span> &#125;,</span><br><span class="line">            completionHandler: &#123; result <span class="keyword">in</span></span><br><span class="line">                <span class="type">CallbackQueue</span>.mainCurrentOrAsync.execute &#123;</span><br><span class="line">                    <span class="comment">// 首先先停止自定义Indicator的动画</span></span><br><span class="line">                    maybeIndicator<span class="operator">?</span>.stopAnimatingView()</span><br><span class="line">                    <span class="comment">// 如果task的Id与当前UIImageView中存储的ID不一致。则说明出现了错误</span></span><br><span class="line">                    <span class="keyword">guard</span> issuedIdentifier <span class="operator">==</span> <span class="keyword">self</span>.taskIdentifier <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> reason: <span class="type">KingfisherError</span>.<span class="type">ImageSettingErrorReason</span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> value <span class="operator">=</span> <span class="keyword">try</span> result.get()</span><br><span class="line">                            reason <span class="operator">=</span> .notCurrentSourceTask(result: value, error: <span class="literal">nil</span>, source: source)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                            reason <span class="operator">=</span> .notCurrentSourceTask(result: <span class="literal">nil</span>, error: error, source: source)</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">let</span> error <span class="operator">=</span> <span class="type">KingfisherError</span>.imageSettingError(reason: reason)</span><br><span class="line">                        completionHandler<span class="operator">?</span>(.failure(error))</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    mutatingSelf.imageTask <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">                    mutatingSelf.taskIdentifier <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">switch</span> result &#123;</span><br><span class="line">                    <span class="comment">// 如果加载成功</span></span><br><span class="line">                    <span class="keyword">case</span> .success(<span class="keyword">let</span> value):</span><br><span class="line">                        <span class="comment">// 判断是否有Transition过程，如果没有直接设置图片并清除placeholder</span></span><br><span class="line">                        <span class="keyword">guard</span> <span class="keyword">self</span>.needsTransition(options: options, cacheType: value.cacheType) <span class="keyword">else</span> &#123;</span><br><span class="line">                            mutatingSelf.placeholder <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">                            <span class="keyword">self</span>.base.image <span class="operator">=</span> value.image</span><br><span class="line">                            completionHandler<span class="operator">?</span>(result)</span><br><span class="line">                            <span class="keyword">return</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果有Transition过程，则通过UIView.transition执行动画过程</span></span><br><span class="line">                        <span class="keyword">self</span>.makeTransition(image: value.image, transition: options.transition) &#123;</span><br><span class="line">                            completionHandler<span class="operator">?</span>(result)</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="comment">// 如果加载失败，调用回调通知错误 </span></span><br><span class="line">                    <span class="keyword">case</span> .failure:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> image <span class="operator">=</span> options.onFailureImage &#123;</span><br><span class="line">                            <span class="keyword">self</span>.base.image <span class="operator">=</span> image</span><br><span class="line">                        &#125;</span><br><span class="line">                        completionHandler<span class="operator">?</span>(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        mutatingSelf.imageTask <span class="operator">=</span> task</span><br><span class="line">        <span class="keyword">return</span> task</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KingfisherManager"><a href="#KingfisherManager" class="headerlink" title="KingfisherManager"></a>KingfisherManager</h3><p>上面的<code>setImage</code>方法中除了对当前所操作的对象（如UIImageView）的状态进行一系列的更新操作之外，最重要的操作就是通过<code>KingfisherManager</code>的<code>retrieve</code>方法生成了图片加载任务</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">retrieveImage</span>(</span><br><span class="line">        <span class="params">with</span> <span class="params">source</span>: <span class="type">Source</span>,</span><br><span class="line">        <span class="params">options</span>: <span class="type">KingfisherParsedOptionsInfo</span>,</span><br><span class="line">        <span class="params">downloadTaskUpdated</span>: <span class="type">DownloadTaskUpdatedBlock</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">        <span class="params">completionHandler</span>: ((<span class="type">Result</span>&lt;<span class="type">RetrieveImageResult</span>, <span class="type">KingfisherError</span>&gt;) -&gt; <span class="type">Void</span>)<span class="operator">?</span>) -&gt; <span class="type">DownloadTask</span>?</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 创建context上下文，方便多个层级之前传递信息</span></span><br><span class="line">    <span class="keyword">var</span> retrievingContext <span class="operator">=</span> <span class="type">RetrievingContext</span>(options: options, originalSource: source)</span><br><span class="line">    <span class="keyword">var</span> retryContext: <span class="type">RetryContext</span>?</span><br><span class="line">    <span class="comment">// 封装重新生成一个新的DownloadTask的逻辑，通过调用另一个retrieveImage方法生成</span></span><br><span class="line">    <span class="comment">// 并将该task更新的消息通过downloadTaskUpdated闭包发送出去</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">startNewRetrieveTask</span>(</span><br><span class="line">        <span class="params">with</span> <span class="params">source</span>: <span class="type">Source</span>,</span><br><span class="line">        <span class="params">downloadTaskUpdated</span>: <span class="type">DownloadTaskUpdatedBlock</span>?</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">let</span> newTask <span class="operator">=</span> <span class="keyword">self</span>.retrieveImage(with: source, context: retrievingContext) &#123; result <span class="keyword">in</span></span><br><span class="line">			handler(currentSource: source, result: result)</span><br><span class="line">		&#125;</span><br><span class="line">        downloadTaskUpdated<span class="operator">?</span>(newTask)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 封装当一个DownloadTask加载图片失败，进行重试的逻辑</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">failCurrentSource</span>(<span class="keyword">_</span> <span class="params">source</span>: <span class="type">Source</span>, <span class="params">with</span> <span class="params">error</span>: <span class="type">KingfisherError</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是用户主动关闭的加载而导致的失败，直接跳过，并回调错误</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>error.isTaskCancelled <span class="keyword">else</span> &#123;</span><br><span class="line">            completionHandler<span class="operator">?</span>(.failure(error))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前的source加载失败，尝试换源加载</span></span><br><span class="line">        <span class="comment">// 从options中查找出了当前的source之外是否有另外可用的source</span></span><br><span class="line">        <span class="comment">// 如果有则用新的source重新创建一个task</span></span><br><span class="line">        <span class="comment">// 如果没有则输出错误</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> nextSource <span class="operator">=</span> retrievingContext.popAlternativeSource() &#123;</span><br><span class="line">            startNewRetrieveTask(with: nextSource, downloadTaskUpdated: downloadTaskUpdated)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> retrievingContext.propagationErrors.isEmpty &#123;</span><br><span class="line">                completionHandler<span class="operator">?</span>(.failure(error))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                retrievingContext.appendError(error, to: source)</span><br><span class="line">                <span class="keyword">let</span> finalError <span class="operator">=</span> <span class="type">KingfisherError</span>.imageSettingError(</span><br><span class="line">                    reason: .alternativeSourcesExhausted(retrievingContext.propagationErrors)</span><br><span class="line">                )</span><br><span class="line">                completionHandler<span class="operator">?</span>(.failure(finalError))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 封装处理图片加载结果的逻辑</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">handler</span>(<span class="params">currentSource</span>: <span class="type">Source</span>, <span class="params">result</span>: (<span class="type">Result</span>&lt;<span class="type">RetrieveImageResult</span>, <span class="type">KingfisherError</span>&gt;)) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> result &#123;</span><br><span class="line">            <span class="comment">// 如果成功，不需要做任何处理，只需要回调结果</span></span><br><span class="line">            <span class="keyword">case</span> .success:</span><br><span class="line">            completionHandler<span class="operator">?</span>(result)</span><br><span class="line">            <span class="comment">// 如果失败尝试重试</span></span><br><span class="line">            <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="comment">// 设置中是否提供了重试策略，如果没有就放弃重试</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> retryStrategy <span class="operator">=</span> options.retryStrategy &#123;</span><br><span class="line">                <span class="comment">// 首先获取传递重试信息的context上下文</span></span><br><span class="line">                <span class="keyword">let</span> context <span class="operator">=</span> retryContext<span class="operator">?</span>.increaseRetryCount() <span class="operator">??</span> </span><br><span class="line">                				<span class="type">RetryContext</span>(source: source, error: error)</span><br><span class="line">                retryContext <span class="operator">=</span> context</span><br><span class="line">				<span class="comment">// 交给设置中的重试策略判断当前是否可以进行重试</span></span><br><span class="line">                retryStrategy.retry(context: context) &#123; decision <span class="keyword">in</span></span><br><span class="line">					<span class="keyword">switch</span> decision &#123;</span><br><span class="line">                        <span class="keyword">case</span> .retry(<span class="keyword">let</span> userInfo):</span><br><span class="line">                        retryContext<span class="operator">?</span>.userInfo <span class="operator">=</span> userInfo</span><br><span class="line">                        <span class="comment">// 如果判断为可以进行重试当前Source，就调用之前我们封装好的逻辑</span></span><br><span class="line">                        <span class="comment">// 重新创建一个当前Source的DownloadTask</span></span><br><span class="line">                        startNewRetrieveTask(with: source, downloadTaskUpdated: downloadTaskUpdated)</span><br><span class="line">                        <span class="comment">// 如果判断为本source需要停止重试，那么就调用之前封装好的逻辑，尝试换源重试</span></span><br><span class="line">                        <span class="keyword">case</span> .stop:</span><br><span class="line">                        failCurrentSource(currentSource, with: error)</span><br><span class="line">                    &#125;</span><br><span class="line">				&#125;</span><br><span class="line">            <span class="comment">// 如果设置中没有重试策略，那么仍然尝试换源重试，只不过不会再进行同源重试了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">guard</span> <span class="operator">!</span>error.isTaskCancelled <span class="keyword">else</span> &#123;</span><br><span class="line">                    completionHandler<span class="operator">?</span>(.failure(error))</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> nextSource <span class="operator">=</span> retrievingContext.popAlternativeSource() &#123;</span><br><span class="line">                    retrievingContext.appendError(error, to: currentSource)</span><br><span class="line">                    startNewRetrieveTask(with: nextSource, downloadTaskUpdated: downloadTaskUpdated)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// No other alternative source. Finish with error.</span></span><br><span class="line">                    <span class="keyword">if</span> retrievingContext.propagationErrors.isEmpty &#123;</span><br><span class="line">                        completionHandler<span class="operator">?</span>(.failure(error))</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        retrievingContext.appendError(error, to: currentSource)</span><br><span class="line">                        <span class="keyword">let</span> finalError <span class="operator">=</span> <span class="type">KingfisherError</span>.imageSettingError(</span><br><span class="line">                            reason: .alternativeSourcesExhausted(retrievingContext.propagationErrors)</span><br><span class="line">                        )</span><br><span class="line">                        completionHandler<span class="operator">?</span>(.failure(finalError))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 然后调用真正用来创建DownloadTask的retrieveImage方法，并将handler作为闭包传进去作为结果处理函数</span></span><br><span class="line">    <span class="keyword">return</span> retrieveImage(</span><br><span class="line">        with: source,</span><br><span class="line">        context: retrievingContext)</span><br><span class="line">    &#123;</span><br><span class="line">        result <span class="keyword">in</span></span><br><span class="line">        handler(currentSource: source, result: result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">retrieveImage</span>(</span><br><span class="line">        <span class="params">with</span> <span class="params">source</span>: <span class="type">Source</span>,</span><br><span class="line">        <span class="params">context</span>: <span class="type">RetrievingContext</span>,</span><br><span class="line">        <span class="params">completionHandler</span>: ((<span class="type">Result</span>&lt;<span class="type">RetrieveImageResult</span>, <span class="type">KingfisherError</span>&gt;) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line">) -&gt; <span class="type">DownloadTask</span>? &#123;</span><br><span class="line">    <span class="keyword">let</span> options <span class="operator">=</span> context.options</span><br><span class="line">    <span class="comment">// 1. 设置中是否强制刷新，如果是那么强制重载并缓存图片数据</span></span><br><span class="line">    <span class="keyword">if</span> options.forceRefresh &#123;</span><br><span class="line">        <span class="keyword">return</span> loadAndCacheImage(</span><br><span class="line">            source: source,</span><br><span class="line">            context: context,</span><br><span class="line">            completionHandler: completionHandler)<span class="operator">?</span>.value</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 先从缓存中加载图片</span></span><br><span class="line">        <span class="keyword">let</span> loadedFromCache <span class="operator">=</span> retrieveImageFromCache(</span><br><span class="line">            source: source,</span><br><span class="line">            context: context,</span><br><span class="line">            completionHandler: completionHandler)</span><br><span class="line">		<span class="comment">// 3. 如果从缓存中找到了对应的图片，则返回nil不生成下载任务，执行结束</span></span><br><span class="line">        <span class="keyword">if</span> loadedFromCache &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 4. 如果设置了只能从缓存中加载对应图片，那么输出错误，执行结束</span></span><br><span class="line">        <span class="keyword">if</span> options.onlyFromCache &#123;</span><br><span class="line">            <span class="keyword">let</span> error <span class="operator">=</span> <span class="type">KingfisherError</span>.cacheError(reason: .imageNotExisting(key: source.cacheKey))</span><br><span class="line">            completionHandler<span class="operator">?</span>(.failure(error))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 5. 缓存中没找到，只能重新加载并缓存图片数据</span></span><br><span class="line">        <span class="keyword">return</span> loadAndCacheImage(</span><br><span class="line">            source: source,</span><br><span class="line">            context: context,</span><br><span class="line">            completionHandler: completionHandler)<span class="operator">?</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图片缓存查找</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">retrieveImageFromCache</span>(</span><br><span class="line">        <span class="params">source</span>: <span class="type">Source</span>,</span><br><span class="line">        <span class="params">context</span>: <span class="type">RetrievingContext</span>,</span><br><span class="line">        <span class="params">completionHandler</span>: ((<span class="type">Result</span>&lt;<span class="type">RetrieveImageResult</span>, <span class="type">KingfisherError</span>&gt;) -&gt; <span class="type">Void</span>)<span class="operator">?</span>) -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> options <span class="operator">=</span> context.options</span><br><span class="line">        <span class="comment">// 1. 首先从targetCache中查找目标图片数据.</span></span><br><span class="line">        <span class="keyword">let</span> targetCache <span class="operator">=</span> options.targetCache <span class="operator">??</span> cache</span><br><span class="line">        <span class="keyword">let</span> key <span class="operator">=</span> source.cacheKey</span><br><span class="line">        <span class="keyword">let</span> targetImageCached <span class="operator">=</span> targetCache.imageCachedType(</span><br><span class="line">            forKey: key, processorIdentifier: options.processor.identifier)</span><br><span class="line">        <span class="comment">// 判断缓存是否有效：是否能找到source对应的图片数据 且 图片缓存数据的来源符合设置中的要求</span></span><br><span class="line">        <span class="comment">// 设置中的fromMemoryCacheOrRefresh表示图片缓存数据应当只来源于内存</span></span><br><span class="line">        <span class="comment">// 所以如果该属性为false或者缓存数据来源为内存的情况下来源是合法的</span></span><br><span class="line">        <span class="keyword">let</span> validCache <span class="operator">=</span> targetImageCached.cached <span class="operator">&amp;&amp;</span></span><br><span class="line">            (options.fromMemoryCacheOrRefresh <span class="operator">==</span> <span class="literal">false</span> <span class="operator">||</span> targetImageCached <span class="operator">==</span> .memory)</span><br><span class="line">        <span class="comment">// 如果缓存有效则处理缓存图片</span></span><br><span class="line">        <span class="keyword">if</span> validCache &#123;</span><br><span class="line">            targetCache.retrieveImage(forKey: key, options: options) &#123; result <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> completionHandler <span class="operator">=</span> completionHandler <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">                options.callbackQueue.execute &#123;</span><br><span class="line">                    result.match(</span><br><span class="line">                        onSuccess: &#123; cacheResult <span class="keyword">in</span></span><br><span class="line">                            <span class="keyword">let</span> value: <span class="type">Result</span>&lt;<span class="type">RetrieveImageResult</span>, <span class="type">KingfisherError</span>&gt;</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> image <span class="operator">=</span> cacheResult.image &#123;</span><br><span class="line">                                value <span class="operator">=</span> result.map &#123;</span><br><span class="line">                                    <span class="type">RetrieveImageResult</span>(</span><br><span class="line">                                        image: image,</span><br><span class="line">                                        cacheType: <span class="variable">$0</span>.cacheType,</span><br><span class="line">                                        source: source,</span><br><span class="line">                                        originalSource: context.originalSource</span><br><span class="line">                                    )</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                value <span class="operator">=</span> .failure(<span class="type">KingfisherError</span>.cacheError(reason: .imageNotExisting(key: key)))</span><br><span class="line">                            &#125;</span><br><span class="line">                            completionHandler(value)</span><br><span class="line">                        &#125;,</span><br><span class="line">                        onFailure: &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">                            completionHandler(.failure(<span class="type">KingfisherError</span>.cacheError(reason: .imageNotExisting(key: key))))</span><br><span class="line">                        &#125;</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. targetCache中没有查找到，从originalCache中查找</span></span><br><span class="line">        <span class="keyword">let</span> originalCache <span class="operator">=</span> options.originalCache <span class="operator">??</span> targetCache</span><br><span class="line">        <span class="keyword">if</span> originalCache <span class="operator">===</span> targetCache <span class="operator">&amp;&amp;</span> options.processor <span class="operator">==</span> <span class="type">DefaultImageProcessor</span>.default &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断缓存是否有效，跟第一步在targetCache中查找的逻辑基本一致</span></span><br><span class="line">        <span class="keyword">let</span> originalImageCacheType <span class="operator">=</span> originalCache.imageCachedType(</span><br><span class="line">            forKey: key, processorIdentifier: <span class="type">DefaultImageProcessor</span>.default.identifier)</span><br><span class="line">        <span class="keyword">let</span> canAcceptDiskCache <span class="operator">=</span> <span class="operator">!</span>options.fromMemoryCacheOrRefresh</span><br><span class="line">        <span class="keyword">let</span> canUseOriginalImageCache <span class="operator">=</span></span><br><span class="line">            (canAcceptDiskCache <span class="operator">&amp;&amp;</span> originalImageCacheType.cached) <span class="operator">||</span></span><br><span class="line">            (<span class="operator">!</span>canAcceptDiskCache <span class="operator">&amp;&amp;</span> originalImageCacheType <span class="operator">==</span> .memory)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// originalCache中查找到有效缓存之后，开始处理缓存中的originalData</span></span><br><span class="line">        <span class="keyword">if</span> canUseOriginalImageCache &#123;</span><br><span class="line">            <span class="keyword">var</span> optionsWithoutProcessor <span class="operator">=</span> options</span><br><span class="line">            optionsWithoutProcessor.processor <span class="operator">=</span> <span class="type">DefaultImageProcessor</span>.default</span><br><span class="line">            originalCache.retrieveImage(forKey: key, options: optionsWithoutProcessor) &#123; result <span class="keyword">in</span></span><br><span class="line">                result.match(</span><br><span class="line">                    onSuccess: &#123; cacheResult <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">guard</span> <span class="keyword">let</span> image <span class="operator">=</span> cacheResult.image <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="built_in">assertionFailure</span>(<span class="string">&quot;The image (under key: <span class="subst">\(key)</span> should be existing in the original cache.&quot;</span>)</span><br><span class="line">                            <span class="keyword">return</span></span><br><span class="line">                        &#125;</span><br><span class="line">						<span class="comment">// 使用processor来处理原始的数据</span></span><br><span class="line">                        <span class="keyword">let</span> processor <span class="operator">=</span> options.processor</span><br><span class="line">                        (options.processingQueue <span class="operator">??</span> <span class="keyword">self</span>.processingQueue).execute &#123;</span><br><span class="line">                            <span class="keyword">let</span> item <span class="operator">=</span> <span class="type">ImageProcessItem</span>.image(image)</span><br><span class="line">                            <span class="keyword">guard</span> <span class="keyword">let</span> processedImage<span class="operator">=</span>processor.process(item: item, options: options) <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">let</span> error <span class="operator">=</span> <span class="type">KingfisherError</span>.processorError(</span><br><span class="line">                                    reason: .processingFailed(processor: processor, item: item))</span><br><span class="line">                                options.callbackQueue.execute &#123; completionHandler<span class="operator">?</span>(.failure(error)) &#125;</span><br><span class="line">                                <span class="keyword">return</span></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">var</span> cacheOptions <span class="operator">=</span> options</span><br><span class="line">                            cacheOptions.callbackQueue <span class="operator">=</span> .untouch</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">let</span> coordinator <span class="operator">=</span> <span class="type">CacheCallbackCoordinator</span>(</span><br><span class="line">                                shouldWaitForCache: options.waitForCache, shouldCacheOriginal: <span class="literal">false</span>)</span><br><span class="line">							<span class="comment">// 原始数据处理成功之后将处理之后的原始数据放入target缓存中，防止重复处理</span></span><br><span class="line">                            targetCache.store(</span><br><span class="line">                                processedImage,</span><br><span class="line">                                forKey: key,</span><br><span class="line">                                options: cacheOptions,</span><br><span class="line">                                toDisk: <span class="operator">!</span>options.cacheMemoryOnly)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">                                coordinator.apply(.cachingImage) &#123;</span><br><span class="line">                                    <span class="keyword">let</span> value <span class="operator">=</span> <span class="type">RetrieveImageResult</span>(</span><br><span class="line">                                        image: processedImage,</span><br><span class="line">                                        cacheType: .none,</span><br><span class="line">                                        source: source,</span><br><span class="line">                                        originalSource: context.originalSource</span><br><span class="line">                                    )</span><br><span class="line">                                    options.callbackQueue.execute &#123; completionHandler<span class="operator">?</span>(.success(value)) &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            coordinator.apply(.cacheInitiated) &#123;</span><br><span class="line">                                <span class="keyword">let</span> value <span class="operator">=</span> <span class="type">RetrieveImageResult</span>(</span><br><span class="line">                                    image: processedImage,</span><br><span class="line">                                    cacheType: .none,</span><br><span class="line">                                    source: source,</span><br><span class="line">                                    originalSource: context.originalSource</span><br><span class="line">                                )</span><br><span class="line">                                options.callbackQueue.execute &#123; completionHandler<span class="operator">?</span>(.success(value)) &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    onFailure: &#123; <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">                        <span class="comment">// 未在缓存中找到对应的数据，实际上这种情况并不会发生</span></span><br><span class="line">                        <span class="comment">// 因为我们是在确定了缓存中有对应的内容之后才去缓存中取对应的数据的</span></span><br><span class="line">                        options.callbackQueue.execute &#123;</span><br><span class="line">                            completionHandler<span class="operator">?</span>(</span><br><span class="line">                                .failure(<span class="type">KingfisherError</span>.cacheError(reason: .imageNotExisting(key: key)))</span><br><span class="line">                            )</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图片加载</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">loadAndCacheImage</span>(</span><br><span class="line">    <span class="params">source</span>: <span class="type">Source</span>,</span><br><span class="line">    <span class="params">context</span>: <span class="type">RetrievingContext</span>,</span><br><span class="line">    <span class="params">completionHandler</span>: ((<span class="type">Result</span>&lt;<span class="type">RetrieveImageResult</span>, <span class="type">KingfisherError</span>&gt;) -&gt; <span class="type">Void</span>)<span class="operator">?</span>) -&gt; <span class="type">DownloadTask</span>.<span class="type">WrappedTask</span>?</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> options <span class="operator">=</span> context.options</span><br><span class="line">    <span class="comment">// 定义内嵌函数，封装了缓存图片的逻辑</span></span><br><span class="line">    <span class="comment">// 在下面的代码中，无论是网络加载图片还是本地加载图片，都会将此内嵌函数作为completionHandler传入</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">_cacheImage</span>(<span class="keyword">_</span> <span class="params">result</span>: <span class="type">Result</span>&lt;<span class="type">ImageLoadingResult</span>, <span class="type">KingfisherError</span>&gt;) &#123;</span><br><span class="line">        cacheImage(</span><br><span class="line">            source: source,</span><br><span class="line">            options: options,</span><br><span class="line">            context: context,</span><br><span class="line">            result: result,</span><br><span class="line">            completionHandler: completionHandler</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> source &#123;</span><br><span class="line">        <span class="comment">// 如果为网络数据，则生成网络下载的task下载网络数据</span></span><br><span class="line">        <span class="keyword">case</span> .network(<span class="keyword">let</span> resource):</span><br><span class="line">        <span class="keyword">let</span> downloader <span class="operator">=</span> options.downloader <span class="operator">??</span> <span class="keyword">self</span>.downloader</span><br><span class="line">        <span class="keyword">let</span> task <span class="operator">=</span> downloader.downloadImage(</span><br><span class="line">            with: resource.downloadURL, options: options, completionHandler: _cacheImage</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> task <span class="operator">=</span> task &#123;</span><br><span class="line">            <span class="keyword">return</span> .download(task)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 如果为本地数据，则返回本地加载数据的task</span></span><br><span class="line">        <span class="keyword">case</span> .provider(<span class="keyword">let</span> provider):</span><br><span class="line">        provideImage(provider: provider, options: options, completionHandler: _cacheImage)</span><br><span class="line">        <span class="keyword">return</span> .dataProviding</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存图片</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面的内嵌函数中调用了另外一个方法cacheImage来实现图片的缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">cacheImage</span>(</span><br><span class="line">    <span class="params">source</span>: <span class="type">Source</span>,</span><br><span class="line">    <span class="params">options</span>: <span class="type">KingfisherParsedOptionsInfo</span>,</span><br><span class="line">    <span class="params">context</span>: <span class="type">RetrievingContext</span>,</span><br><span class="line">    <span class="params">result</span>: <span class="type">Result</span>&lt;<span class="type">ImageLoadingResult</span>, <span class="type">KingfisherError</span>&gt;,</span><br><span class="line">    <span class="params">completionHandler</span>: ((<span class="type">Result</span>&lt;<span class="type">RetrieveImageResult</span>, <span class="type">KingfisherError</span>&gt;) -&gt; <span class="type">Void</span>)<span class="operator">?</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="keyword">let</span> needToCacheOriginalImage <span class="operator">=</span> options.cacheOriginalImage <span class="operator">&amp;&amp;</span></span><br><span class="line">        options.processor <span class="operator">!=</span> <span class="type">DefaultImageProcessor</span>.default</span><br><span class="line">        <span class="keyword">let</span> coordinator <span class="operator">=</span> <span class="type">CacheCallbackCoordinator</span>(</span><br><span class="line">            shouldWaitForCache: options.waitForCache, shouldCacheOriginal: needToCacheOriginalImage)</span><br><span class="line">        <span class="comment">// Add image to cache.</span></span><br><span class="line">        <span class="keyword">let</span> targetCache <span class="operator">=</span> options.targetCache <span class="operator">??</span> <span class="keyword">self</span>.cache</span><br><span class="line">        targetCache.store(</span><br><span class="line">            value.image,</span><br><span class="line">            original: value.originalData,</span><br><span class="line">            forKey: source.cacheKey,</span><br><span class="line">            options: options,</span><br><span class="line">            toDisk: <span class="operator">!</span>options.cacheMemoryOnly)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">            coordinator.apply(.cachingImage) &#123;</span><br><span class="line">                <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">RetrieveImageResult</span>(</span><br><span class="line">                    image: value.image,</span><br><span class="line">                    cacheType: .none,</span><br><span class="line">                    source: source,</span><br><span class="line">                    originalSource: context.originalSource</span><br><span class="line">                )</span><br><span class="line">                completionHandler<span class="operator">?</span>(.success(result))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add original image to cache if necessary.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> needToCacheOriginalImage &#123;</span><br><span class="line">            <span class="keyword">let</span> originalCache <span class="operator">=</span> options.originalCache <span class="operator">??</span> targetCache</span><br><span class="line">            originalCache.storeToDisk(</span><br><span class="line">                value.originalData,</span><br><span class="line">                forKey: source.cacheKey,</span><br><span class="line">                processorIdentifier: <span class="type">DefaultImageProcessor</span>.default.identifier,</span><br><span class="line">                expiration: options.diskCacheExpiration)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">_</span> <span class="keyword">in</span></span><br><span class="line">                coordinator.apply(.cachingOriginalImage) &#123;</span><br><span class="line">                    <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">RetrieveImageResult</span>(</span><br><span class="line">                        image: value.image,</span><br><span class="line">                        cacheType: .none,</span><br><span class="line">                        source: source,</span><br><span class="line">                        originalSource: context.originalSource</span><br><span class="line">                    )</span><br><span class="line">                    completionHandler<span class="operator">?</span>(.success(result))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        coordinator.apply(.cacheInitiated) &#123;</span><br><span class="line">            <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">RetrieveImageResult</span>(</span><br><span class="line">                image: value.image,</span><br><span class="line">                cacheType: .none,</span><br><span class="line">                source: source,</span><br><span class="line">                originalSource: context.originalSource</span><br><span class="line">            )</span><br><span class="line">            completionHandler<span class="operator">?</span>(.success(result))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        completionHandler<span class="operator">?</span>(.failure(error))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一些细节：上面的代码中我们经常会用到CacheCallbackCoordinator类，这个类主要负责记录当前缓存的状态，并根据状态之间的改变有条件的触发trigger闭包，其核心代码在下方</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">swift<span class="comment">// 负责更新缓存状态，并且按照当前的状态与将要更新的状态组合来有条件地执行通过参数传入的trigger闭包</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">apply</span>(<span class="keyword">_</span> <span class="params">action</span>: <span class="type">Action</span>, <span class="params">trigger</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (state, action) &#123;</span><br><span class="line">    <span class="keyword">case</span> (.done, <span class="keyword">_</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        <span class="comment">// From .idle</span></span><br><span class="line">	<span class="keyword">case</span> (.idle, .cacheInitiated):</span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>shouldWaitForCache &#123;</span><br><span class="line">            state <span class="operator">=</span> .done</span><br><span class="line">            trigger()</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">case</span> (.idle, .cachingImage):</span><br><span class="line">        <span class="keyword">if</span> shouldCacheOriginal &#123;</span><br><span class="line">            state <span class="operator">=</span> .imageCached</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            state <span class="operator">=</span> .done</span><br><span class="line">            trigger()</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">case</span> (.idle, .cachingOriginalImage):</span><br><span class="line">        state <span class="operator">=</span> .originalImageCached</span><br><span class="line">        <span class="comment">// From .imageCached</span></span><br><span class="line">        <span class="keyword">case</span> (.imageCached, .cachingOriginalImage):</span><br><span class="line">        state <span class="operator">=</span> .done</span><br><span class="line">        trigger()</span><br><span class="line">        <span class="comment">// From .originalImageCached</span></span><br><span class="line">	<span class="keyword">case</span> (.originalImageCached, .cachingImage):</span><br><span class="line">        state <span class="operator">=</span> .done</span><br><span class="line">        trigger()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">assertionFailure</span>(<span class="string">&quot;This case should not happen in CacheCallbackCoordinator: <span class="subst">\(state)</span> - <span class="subst">\(action)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>上面的KingfisherManager的代码当中经常会使用到targetCache与originalCache都是ImageCache的一个单例对象，ImageCache类的内部吃用内存存储与硬盘存储的实例，并且会监听系统相关的状态变化并响应变化。收到<code>UIApplication.didReceiveNotification</code>之后会主动清理内存缓存，收到<code>UIApplication.WillTerminateNotification</code>之后会主动清理已经过期的缓存，收到<code>UIApplication.didEnterBackgrounNotification</code>之后会在后台清理过气的缓存</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageCache类属性的简单代码</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">ImageCache</span> &#123;</span><br><span class="line">    <span class="comment">// 单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> `default` <span class="operator">=</span> <span class="type">ImageCache</span>(name: <span class="string">&quot;default&quot;</span>)</span><br><span class="line">    <span class="comment">// 内存存储对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> memoryStorage: <span class="type">MemoryStorage</span>.<span class="type">Backend</span>&lt;<span class="type">KFCrossPlatformImage</span>&gt;</span><br><span class="line">    <span class="comment">// 硬盘存储对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> diskStorage: <span class="type">DiskStorage</span>.<span class="type">Backend</span>&lt;<span class="type">Data</span>&gt;</span><br><span class="line">    <span class="comment">// 要工作于哪一个队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> ioQueue: <span class="type">DispatchQueue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在外部，我们通过调用ImageCache的store方法来向缓存中插入图片数据</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">store</span>(</span><br><span class="line">    <span class="keyword">_</span> <span class="params">image</span>: <span class="type">KFCrossPlatformImage</span>,</span><br><span class="line">    <span class="params">original</span>: <span class="type">Data</span>? <span class="operator">=</span> <span class="literal">nil</span>,</span><br><span class="line">    <span class="params">forKey</span> <span class="params">key</span>: <span class="type">String</span>,</span><br><span class="line">    <span class="params">options</span>: <span class="type">KingfisherParsedOptionsInfo</span>,</span><br><span class="line">    <span class="params">toDisk</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span>,</span><br><span class="line">    <span class="params">completionHandler</span>: ((<span class="type">CacheStoreResult</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">)&#123;</span><br><span class="line">    <span class="keyword">let</span> identifier <span class="operator">=</span> options.processor.identifier</span><br><span class="line">    <span class="keyword">let</span> callbackQueue <span class="operator">=</span> options.callbackQueue</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> computedKey <span class="operator">=</span> key.computedKey(with: identifier)</span><br><span class="line">    <span class="comment">// 先将图片存储在内存当中</span></span><br><span class="line">    memoryStorage.storeNoThrow(value: image, forKey: computedKey, expiration: options.memoryCacheExpiration)</span><br><span class="line">	<span class="comment">// 接着判断是否需要存储到硬盘，如果不需要直接调用回调然后结束流程</span></span><br><span class="line">    <span class="keyword">guard</span> toDisk <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> completionHandler <span class="operator">=</span> completionHandler &#123;</span><br><span class="line">            <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">CacheStoreResult</span>(memoryCacheResult: .success(()), diskCacheResult: .success(()))</span><br><span class="line">            callbackQueue.execute &#123; completionHandler(result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 将图片数据序列化之后存储到硬盘当中</span></span><br><span class="line">    ioQueue.async &#123;</span><br><span class="line">        <span class="keyword">let</span> serializer <span class="operator">=</span> options.cacheSerializer</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> serializer.data(with: image, original: original) &#123;</span><br><span class="line">            <span class="keyword">self</span>.syncStoreToDisk(</span><br><span class="line">                data,</span><br><span class="line">                forKey: key,</span><br><span class="line">                processorIdentifier: identifier,</span><br><span class="line">                callbackQueue: callbackQueue,</span><br><span class="line">                expiration: options.diskCacheExpiration,</span><br><span class="line">                completionHandler: completionHandler)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> completionHandler <span class="operator">=</span> completionHandler <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> diskError <span class="operator">=</span> <span class="type">KingfisherError</span>.cacheError(</span><br><span class="line">                reason: .cannotSerializeImage(image: image, original: original, serializer: serializer))</span><br><span class="line">            <span class="keyword">let</span> result <span class="operator">=</span> <span class="type">CacheStoreResult</span>(</span><br><span class="line">                memoryCacheResult: .success(()),</span><br><span class="line">                diskCacheResult: .failure(diskError))</span><br><span class="line">            callbackQueue.execute &#123; completionHandler(result) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储至内存：MemoryStorage实例的storeNoThrow方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">storeNoThrow</span>(</span><br><span class="line">    <span class="params">value</span>: <span class="type">T</span>,</span><br><span class="line">    <span class="params">forKey</span> <span class="params">key</span>: <span class="type">String</span>,</span><br><span class="line">    <span class="params">expiration</span>: <span class="type">StorageExpiration</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先加解锁保证这是一个线程安全的操作</span></span><br><span class="line">    lock.lock()</span><br><span class="line">    <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">    <span class="comment">// 如果在存储是判断图片的缓存已经到期，那么就不再进行存储</span></span><br><span class="line">    <span class="keyword">let</span> expiration <span class="operator">=</span> expiration <span class="operator">??</span> config.expiration</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>expiration.isExpired <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">	<span class="comment">// 由键值对生成一个StorageObject</span></span><br><span class="line">    <span class="keyword">let</span> object <span class="operator">=</span> <span class="type">StorageObject</span>(value, key: key, expiration: expiration)</span><br><span class="line">    <span class="comment">// 将键值对与键存储入自身的storage属性中去，自身的storage属性是一个NSCache对象</span></span><br><span class="line">    storage.setObject(object, forKey: key <span class="keyword">as</span> <span class="type">NSString</span>, cost: value.cacheCost)</span><br><span class="line">    <span class="comment">// 同时为了可以快速判断缓存中是否存在某个键的数据，拥有一个keys的set属性用来放置键</span></span><br><span class="line">    keys.insert(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储至硬盘：DiskStorage实例的store方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">store</span>(</span><br><span class="line">    <span class="params">value</span>: <span class="type">T</span>,</span><br><span class="line">    <span class="params">forKey</span> <span class="params">key</span>: <span class="type">String</span>,</span><br><span class="line">    <span class="params">expiration</span>: <span class="type">StorageExpiration</span>? <span class="operator">=</span> <span class="literal">nil</span>) <span class="keyword">throws</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果在存储是判断图片的缓存已经到期，那么就不再进行存储</span></span><br><span class="line">    <span class="keyword">let</span> expiration <span class="operator">=</span> expiration <span class="operator">??</span> config.expiration</span><br><span class="line">    <span class="keyword">guard</span> <span class="operator">!</span>expiration.isExpired <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">	<span class="comment">// 参数value接受DataTransformable协议的泛型，下面尝试将value转成data类型的数据</span></span><br><span class="line">    <span class="keyword">let</span> data: <span class="type">Data</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        data <span class="operator">=</span> <span class="keyword">try</span> value.toData()</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">KingfisherError</span>.cacheError(reason: .cannotConvertToData(object: value, error: error))</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 根据key来计算该数据应该存储的位置，并将数据写出对应路径的文件中</span></span><br><span class="line">    <span class="keyword">let</span> fileURL <span class="operator">=</span> cacheFileURL(forKey: key)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> data.write(to: fileURL)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">KingfisherError</span>.cacheError(</span><br><span class="line">            reason: .cannotCreateCacheFile(fileURL: fileURL, key: key, data: data, error: error)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 尝试将文件创建时间以及缓存过期时间信息写入文件的元数据中</span></span><br><span class="line">    <span class="keyword">let</span> now <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line">    <span class="keyword">let</span> attributes: [<span class="type">FileAttributeKey</span> : <span class="keyword">Any</span>] <span class="operator">=</span> [</span><br><span class="line">        <span class="comment">// The last access date.</span></span><br><span class="line">        .creationDate: now.fileAttributeDate,</span><br><span class="line">        <span class="comment">// The estimated expiration date.</span></span><br><span class="line">        .modificationDate: expiration.estimatedExpirationSinceNow.fileAttributeDate</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> config.fileManager.setAttributes(attributes, ofItemAtPath: fileURL.path)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">try?</span> config.fileManager.removeItem(at: fileURL)</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">KingfisherError</span>.cacheError(</span><br><span class="line">            reason: .cannotSetCacheFileAttribute(</span><br><span class="line">                filePath: fileURL.path,</span><br><span class="line">                attributes: attributes,</span><br><span class="line">                error: error</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maybeCachedCheckingQueue.async &#123;</span><br><span class="line">        <span class="keyword">self</span>.maybeCached<span class="operator">?</span>.insert(fileURL.lastPathComponent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关通知的监听</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notifications <span class="operator">=</span> [</span><br><span class="line">    <span class="comment">// 收到内存警告的时候，清除所有的内存缓存</span></span><br><span class="line">    (<span class="type">UIApplication</span>.didReceiveMemoryWarningNotification, <span class="keyword">#selector</span>(clearMemoryCache)),</span><br><span class="line">    <span class="comment">// APP将要Terminate的时候，清除所有的硬盘缓存</span></span><br><span class="line">    (<span class="type">UIApplication</span>.willTerminateNotification, <span class="keyword">#selector</span>(cleanExpiredDiskCache)),</span><br><span class="line">    <span class="comment">// 当APP进入后台时也清理硬盘缓存</span></span><br><span class="line">    (<span class="type">UIApplication</span>.didEnterBackgroundNotification, <span class="keyword">#selector</span>(backgroundCleanExpiredDiskCache))</span><br><span class="line">]</span><br><span class="line">notifications.forEach &#123;</span><br><span class="line">    <span class="type">NotificationCenter</span>.default.addObserver(<span class="keyword">self</span>, selector: <span class="variable">$0</span>.<span class="number">1</span>, name: <span class="variable">$0</span>.<span class="number">0</span>, object: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清理所有内存缓存</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">clearMemoryCache</span>() &#123;</span><br><span class="line">    <span class="keyword">try?</span> memoryStorage.removeAll()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清理过期硬盘缓存</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">cleanExpiredDiskCache</span>() &#123;</span><br><span class="line">    cleanExpiredDiskCache(completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// APP进入后台</span></span><br><span class="line"><span class="keyword">@objc</span> <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">backgroundCleanExpiredDiskCache</span>() &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> sharedApplication <span class="operator">=</span> <span class="type">KingfisherWrapper</span>&lt;<span class="type">UIApplication</span>&gt;.shared <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">	<span class="comment">// 封装结束后台任务的逻辑</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">endBackgroundTask</span>(<span class="keyword">_</span> <span class="params">task</span>: <span class="keyword">inout</span> <span class="type">UIBackgroundTaskIdentifier</span>) &#123;</span><br><span class="line">        sharedApplication.endBackgroundTask(task)</span><br><span class="line">        <span class="keyword">#if</span> swift(<span class="operator">&gt;=</span><span class="number">4.2</span>)</span><br><span class="line">        task <span class="operator">=</span> <span class="type">UIBackgroundTaskIdentifier</span>.invalid</span><br><span class="line">        <span class="keyword">#else</span></span><br><span class="line">        task <span class="operator">=</span> <span class="type">UIBackgroundTaskInvalid</span></span><br><span class="line">        <span class="keyword">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 创建后台任务</span></span><br><span class="line">    <span class="keyword">var</span> backgroundTask: <span class="type">UIBackgroundTaskIdentifier</span>!</span><br><span class="line">    backgroundTask <span class="operator">=</span> sharedApplication.beginBackgroundTask &#123;</span><br><span class="line">        endBackgroundTask(<span class="operator">&amp;</span>backgroundTask<span class="operator">!</span>)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 调用cleanExpiredDiskCache清理过期硬盘缓存，完成之后也销毁后台任务</span></span><br><span class="line">    cleanExpiredDiskCache &#123;</span><br><span class="line">        endBackgroundTask(<span class="operator">&amp;</span>backgroundTask<span class="operator">!</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存移除</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">removeImage</span>(<span class="params">forKey</span> <span class="params">key</span>: <span class="type">String</span>,</span><br><span class="line">                      <span class="params">processorIdentifier</span> <span class="params">identifier</span>: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">                      <span class="params">fromMemory</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span>,</span><br><span class="line">                      <span class="params">fromDisk</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span>,</span><br><span class="line">                      <span class="params">callbackQueue</span>: <span class="type">CallbackQueue</span> <span class="operator">=</span> .untouch,</span><br><span class="line">                      <span class="params">completionHandler</span>: (() -&gt; <span class="type">Void</span>)<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> computedKey <span class="operator">=</span> key.computedKey(with: identifier)</span><br><span class="line">	<span class="comment">// 如果标注了要从内存中删除，就调用内存缓存实例memoryStorage的remove方法来删除缓存</span></span><br><span class="line">    <span class="keyword">if</span> fromMemory &#123;</span><br><span class="line">        <span class="keyword">try?</span> memoryStorage.remove(forKey: computedKey)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 如果标注了要从硬盘中删除，就调用硬盘缓存实例diskStorage的remove方法来删除缓存</span></span><br><span class="line">    <span class="keyword">if</span> fromDisk &#123;</span><br><span class="line">        ioQueue.async&#123;</span><br><span class="line">            <span class="keyword">try?</span> <span class="keyword">self</span>.diskStorage.remove(forKey: computedKey)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> completionHandler <span class="operator">=</span> completionHandler &#123;</span><br><span class="line">                callbackQueue.execute &#123; completionHandler() &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> completionHandler <span class="operator">=</span> completionHandler &#123;</span><br><span class="line">            callbackQueue.execute &#123; completionHandler() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内存缓存实例memoryStorage的remove方法：从NSCache中移除对应Key的数据，并删除Key</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">remove</span>(<span class="params">forKey</span> <span class="params">key</span>: <span class="type">String</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    lock.lock()</span><br><span class="line">    <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">    storage.removeObject(forKey: key <span class="keyword">as</span> <span class="type">NSString</span>)</span><br><span class="line">    keys.remove(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 硬盘缓存实例diskStorage的remove方法：使用FileManager删除特定文件</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">removeFile</span>(<span class="params">at</span> <span class="params">url</span>: <span class="type">URL</span>) <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> config.fileManager.removeItem(at: url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="网络加载"><a href="#网络加载" class="headerlink" title="网络加载"></a>网络加载</h3><p>如果缓存中没有查找到对应的图片数据，则会生成一个DownloadTask来下载图片的数据。从下面的代码中可以看出来DownloadTask只是对SessionDataTask的简单封装，核心的图片下载逻辑室友SessionDataTask完成的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">DownloadTask</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> sessionTask: <span class="type">SessionDataTask</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> cancelToken: <span class="type">SessionDataTask</span>.<span class="type">CancelToken</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">cancel</span>() &#123;</span><br><span class="line">        sessionTask.cancel(token: cancelToken)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SessionDataTask</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionDataTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">CancelToken</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TaskCallback</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> onCompleted: <span class="type">Delegate</span>&lt;<span class="type">Result</span>&lt;<span class="type">ImageLoadingResult</span>, <span class="type">KingfisherError</span>&gt;, <span class="type">Void</span>&gt;?</span><br><span class="line">        <span class="keyword">let</span> options: <span class="type">KingfisherParsedOptionsInfo</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 当前任务下载到的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private(set)</span> <span class="keyword">var</span> mutableData: <span class="type">Data</span></span><br><span class="line">    <span class="comment">// 底层的原生URLSessionDataTask</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> task: <span class="type">URLSessionDataTask</span></span><br><span class="line">    <span class="comment">// 回调容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> callbacksStore <span class="operator">=</span> [<span class="type">CancelToken</span>: <span class="type">TaskCallback</span>]()</span><br><span class="line">    <span class="keyword">var</span> callbacks: [<span class="type">SessionDataTask</span>.<span class="type">TaskCallback</span>] &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Array</span>(callbacksStore.values)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 记录当前的Token，SessionDataTask通过自增Token的方式给每一个回调都分配一个唯一的Token值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentToken <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> lock <span class="operator">=</span> <span class="type">NSLock</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> onTaskDone <span class="operator">=</span> <span class="type">Delegate</span>&lt;(<span class="type">Result</span>&lt;(<span class="type">Data</span>, <span class="type">URLResponse</span>?), <span class="type">KingfisherError</span>&gt;, [<span class="type">TaskCallback</span>]), <span class="type">Void</span>&gt;()</span><br><span class="line">    <span class="keyword">let</span> onCallbackCancelled <span class="operator">=</span> <span class="type">Delegate</span>&lt;(<span class="type">CancelToken</span>, <span class="type">TaskCallback</span>), <span class="type">Void</span>&gt;()</span><br><span class="line">	<span class="comment">// 标识SessionDataTask是否正在运行</span></span><br><span class="line">    <span class="keyword">var</span> started <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> containsCallbacks: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="operator">!</span>callbacks.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">task</span>: <span class="type">URLSessionDataTask</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.task <span class="operator">=</span> task</span><br><span class="line">        mutableData <span class="operator">=</span> <span class="type">Data</span>()</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 向SessionDataTask实例的回调仓库中添加一个回调</span></span><br><span class="line">    <span class="comment">// 添加一个回调会返回该回调对应的一个CancelToken</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">addCallback</span>(<span class="keyword">_</span> <span class="params">callback</span>: <span class="type">TaskCallback</span>) -&gt; <span class="type">CancelToken</span> &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">        callbacksStore[currentToken] <span class="operator">=</span> callback</span><br><span class="line">        <span class="keyword">defer</span> &#123; currentToken <span class="operator">+=</span> <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> currentToken</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 移除特定CancelToken对应的回调</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">removeCallback</span>(<span class="keyword">_</span> <span class="params">token</span>: <span class="type">CancelToken</span>) -&gt; <span class="type">TaskCallback</span>? &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> callback <span class="operator">=</span> callbacksStore[token] &#123;</span><br><span class="line">            callbacksStore[token] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">return</span> callback</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 开始请求：将started状态标识设置为true并调用底层原生的URLSessionDataTask实例的resume方法来开启网络请求</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">resume</span>() &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>started <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        started <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 根据CancelToken关闭（清除）对应的回调，如果关闭之后SessionDataTask的回调数为空</span></span><br><span class="line">    <span class="comment">// 则彻底关掉底层的URLSessionDataTask网络任务</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">cancel</span>(<span class="params">token</span>: <span class="type">CancelToken</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> callback <span class="operator">=</span> removeCallback(token) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> callbacksStore.count <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">            task.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">        onCallbackCancelled.call((token, callback))</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 清除所有的回调，并关闭底层的URLSessionDataTask</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">forceCancel</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> callbacksStore.keys &#123;</span><br><span class="line">            cancel(token: token)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// SessionDataTask接收到了先传递进来的数据，更新自己存储的数据</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">didReceiveData</span>(<span class="keyword">_</span> <span class="params">data</span>: <span class="type">Data</span>) &#123;</span><br><span class="line">        mutableData.append(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SessionDataTask是对原生URLSessionDataTask的简单封装，初始化时需要传入一个已经创建好的URLSessionDataTask，而URLSessionDataTask是由URLSession生成的，ImageDownloader就是负责这个的：管理全局的URLSession，并创建URLSessionDataTask，最后再创建出SessionDataTask</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageDownloader的初始化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">&quot;[Kingfisher] You should specify a name for the downloader. &quot;</span></span><br><span class="line">                   <span class="operator">+</span> <span class="string">&quot;A downloader with empty name is not permitted.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">	<span class="comment">// 初始化了SessionDelegate和URLSession</span></span><br><span class="line">    sessionDelegate <span class="operator">=</span> <span class="type">SessionDelegate</span>()</span><br><span class="line">    session <span class="operator">=</span> <span class="type">URLSession</span>(</span><br><span class="line">        configuration: sessionConfiguration,</span><br><span class="line">        delegate: sessionDelegate,</span><br><span class="line">        delegateQueue: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    authenticationChallengeResponder <span class="operator">=</span> <span class="keyword">self</span></span><br><span class="line">    setupSessionHandler()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ImageDownloader通过downloadImage方法来创建SessionDataTask</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在开始进一步的分析之前，我们先来看一个KF中的工具类Delegate</span></span><br><span class="line"><span class="comment">// Delegate是对代理模式的一个简单封装，我们不再需要像传统代理模式那样定义协议，实现协议，将特定类作为代理传递给某个需要他的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span>&lt;<span class="type">Input</span>, <span class="type">Output</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 存储一个block</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> block: ((<span class="type">Input</span>) -&gt; <span class="type">Output</span>?)<span class="operator">?</span></span><br><span class="line">    <span class="comment">// 添加代理逻辑，在传统的代理协议开发模式下相当于给某个类实现代理协议，并将该类的某个对象传递给需要用到这个代理的地方</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">delegate</span>&lt;<span class="type">T</span>: <span class="type">AnyObject</span>&gt;(<span class="params">on</span> <span class="params">target</span>: <span class="type">T</span>, <span class="params">block</span>: ((<span class="type">T</span>, <span class="type">Input</span>) -&gt; <span class="type">Output</span>)<span class="operator">?</span>) &#123;</span><br><span class="line">        <span class="comment">// The `target` is weak inside block, so you do not need to worry about it in the caller side.</span></span><br><span class="line">        <span class="keyword">self</span>.block <span class="operator">=</span> &#123; [<span class="keyword">weak</span> target] input <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> target <span class="operator">=</span> target <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">            <span class="keyword">return</span> block<span class="operator">?</span>(target, input)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发代理方法，相当于传统的代理开发模式下代理的持有者调用代理的方法</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">call</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="type">Input</span>) -&gt; <span class="type">Output</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> block<span class="operator">?</span>(input)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ImageDownloader中的sessionConfiguration默认为.ephemeral（非持久化，无痕）</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">var</span> sessionConfiguration <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.ephemeral &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        session.invalidateAndCancel()</span><br><span class="line">        session <span class="operator">=</span> <span class="type">URLSession</span>(</span><br><span class="line">            configuration: sessionConfiguration,</span><br><span class="line">            delegate:sessionDelegate,</span><br><span class="line">            delegateQueue: <span class="literal">nil</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@discardableResult</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">downloadImage</span>(</span><br><span class="line">    <span class="params">with</span> <span class="params">url</span>: <span class="type">URL</span>,</span><br><span class="line">    <span class="params">options</span>: <span class="type">KingfisherParsedOptionsInfo</span>,</span><br><span class="line">    <span class="params">completionHandler</span>: ((<span class="type">Result</span>&lt;<span class="type">ImageLoadingResult</span>, <span class="type">KingfisherError</span>&gt;) -&gt; <span class="type">Void</span>)<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span>) -&gt; <span class="type">DownloadTask</span>?</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建默认的请求</span></span><br><span class="line">    <span class="keyword">var</span> request <span class="operator">=</span> <span class="type">URLRequest</span>(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: downloadTimeout)</span><br><span class="line">    request.httpShouldUsePipelining <span class="operator">=</span> requestsUsePipelining</span><br><span class="line">	<span class="comment">// 如果参数中给了RequestModifier，那么首先对创建的请求应用这个Modifier</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> requestModifier <span class="operator">=</span> options.requestModifier &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> r <span class="operator">=</span> requestModifier.modified(for: request) <span class="keyword">else</span> &#123;</span><br><span class="line">            options.callbackQueue.execute &#123;</span><br><span class="line">                completionHandler<span class="operator">?</span>(.failure(<span class="type">KingfisherError</span>.requestError(reason: .emptyRequest)))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        request <span class="operator">=</span> r</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 在对request应用了Modifier之后对request的url进行判空，防止在Modifier中将request的url设置为了nil</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> request.url, <span class="operator">!</span>url.absoluteString.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        options.callbackQueue.execute &#123;</span><br><span class="line">            completionHandler<span class="operator">?</span>(.failure(<span class="type">KingfisherError</span>.requestError(reason: .invalidURL(request: request))))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将completionHandler包装成Delegate对象</span></span><br><span class="line">    <span class="keyword">let</span> onCompleted <span class="operator">=</span> completionHandler.map &#123;</span><br><span class="line">        block -&gt; <span class="type">Delegate</span>&lt;<span class="type">Result</span>&lt;<span class="type">ImageLoadingResult</span>, <span class="type">KingfisherError</span>&gt;, <span class="type">Void</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> delegate <span class="operator">=</span>  <span class="type">Delegate</span>&lt;<span class="type">Result</span>&lt;<span class="type">ImageLoadingResult</span>, <span class="type">KingfisherError</span>&gt;, <span class="type">Void</span>&gt;()</span><br><span class="line">        delegate.delegate(on: <span class="keyword">self</span>) &#123; (<span class="keyword">_</span>, callback) <span class="keyword">in</span></span><br><span class="line">                                     block(callback)</span><br><span class="line">                                    &#125;</span><br><span class="line">        <span class="keyword">return</span> delegate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再把Delegate对象包装为TaskCallback对象</span></span><br><span class="line">    <span class="keyword">let</span> callback <span class="operator">=</span> <span class="type">SessionDataTask</span>.<span class="type">TaskCallback</span>(</span><br><span class="line">        onCompleted: onCompleted,</span><br><span class="line">        options: options</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果已经存在一个相同URL的下载任务，那么就只是取出这个任务，向该任务中新添加一个TaskCallback</span></span><br><span class="line">    <span class="comment">// 如果不存在，那么久重新创建一个，并将重新创建的downloadTask添加到sessionDelegate对象中</span></span><br><span class="line">    <span class="keyword">let</span> downloadTask: <span class="type">DownloadTask</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> existingTask <span class="operator">=</span> sessionDelegate.task(for: url) &#123;</span><br><span class="line">        downloadTask <span class="operator">=</span> sessionDelegate.append(existingTask, url: url, callback: callback)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sessionDataTask <span class="operator">=</span> session.dataTask(with: request)</span><br><span class="line">        sessionDataTask.priority <span class="operator">=</span> options.downloadPriority</span><br><span class="line">        downloadTask <span class="operator">=</span> sessionDelegate.add(sessionDataTask, url: url, callback: callback)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果对应URL的SessionDataTask先前就存在，并且上一次的请求还未结束，那么就不需要做任何操作</span></span><br><span class="line">    <span class="comment">// 直接返回downloadTask即可，因为等到此次未结束的请求有数据更新的时候会直接调用我们之前添加进去的TaskCallback</span></span><br><span class="line">    <span class="comment">// 如果对应URL的SessionDataTask并没有正在请求的状态，那么我们需要手动resume该task</span></span><br><span class="line">    <span class="comment">// 但在resume之前我们需要为这一次的请求添加一个请求完成的回调</span></span><br><span class="line">    <span class="keyword">if</span> <span class="operator">!</span>sessionTask.started &#123;</span><br><span class="line">        sessionTask.onTaskDone.delegate(on: <span class="keyword">self</span>) &#123; (<span class="keyword">self</span>, done) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// Underlying downloading finishes.</span></span><br><span class="line">            <span class="comment">// result: Result&lt;(Data, URLResponse?)&gt;, callbacks: [TaskCallback]</span></span><br><span class="line">            <span class="keyword">let</span> (result, callbacks) <span class="operator">=</span> done</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求完成之后，分析结果是正确（URLResponse）还是错误（Error），并将结果通知出去</span></span><br><span class="line">			<span class="comment">// delegate是一个遵循ImageDownloaderDelegate代理协议的代理属性</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> value <span class="operator">=</span> <span class="keyword">try</span> result.get()</span><br><span class="line">                <span class="keyword">self</span>.delegate<span class="operator">?</span>.imageDownloader(</span><br><span class="line">                    <span class="keyword">self</span>,</span><br><span class="line">                    didFinishDownloadingImageForURL: url,</span><br><span class="line">                    with: value.<span class="number">1</span>,</span><br><span class="line">                    error: <span class="literal">nil</span></span><br><span class="line">                )</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.delegate<span class="operator">?</span>.imageDownloader(</span><br><span class="line">                    <span class="keyword">self</span>,</span><br><span class="line">                    didFinishDownloadingImageForURL: url,</span><br><span class="line">                    with: <span class="literal">nil</span>,</span><br><span class="line">                    error: error</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 另外，除了在请求结束收到响应的时候将结果通知出去之外</span></span><br><span class="line">			<span class="comment">// 如果请求成功了，那么会开启一个数据转换任务，尝试将响应中的数据转换为一个图片数据</span></span><br><span class="line">            <span class="keyword">switch</span> result &#123;</span><br><span class="line">            <span class="keyword">case</span> .success(<span class="keyword">let</span> (data, response)):</span><br><span class="line">                <span class="comment">// 创建图片数据处理器</span></span><br><span class="line">                <span class="keyword">let</span> processor <span class="operator">=</span> <span class="type">ImageDataProcessor</span>(</span><br><span class="line">                    data: data,</span><br><span class="line">                    callbacks: callbacks</span><br><span class="line">                    processingQueue: options.processingQueue</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">// 给处理器添加回调，在图片数据处理完成之后将结果通知给代理属性和SessionDataTask中的回调</span></span><br><span class="line">                processor.onImageProcessed.delegate(on: <span class="keyword">self</span>) &#123; (<span class="keyword">self</span>, result) <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">let</span> (result, callback) <span class="operator">=</span> result</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> image <span class="operator">=</span> <span class="keyword">try?</span> result.get() &#123;</span><br><span class="line">                        <span class="keyword">self</span>.delegate<span class="operator">?</span>.imageDownloader(<span class="keyword">self</span>, didDownload: image, for: url, with: response)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">let</span> imageResult <span class="operator">=</span> result.map &#123;</span><br><span class="line">                        <span class="type">ImageLoadingResult</span>(image: <span class="variable">$0</span>, url: url, originalData: data)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">let</span> queue <span class="operator">=</span> callback.options.callbackQueue</span><br><span class="line">                    queue.execute &#123; callback.onCompleted<span class="operator">?</span>.call(imageResult) &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 开始处理图片数据</span></span><br><span class="line">                processor.process()</span><br><span class="line">			<span class="comment">// 如果请求失败，则把错误通知给SessionDataTask中的回调</span></span><br><span class="line">            <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">                callbacks.forEach &#123; callback <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">let</span> queue <span class="operator">=</span> callback.options.callbackQueue</span><br><span class="line">                    queue.execute &#123; callback.onCompleted<span class="operator">?</span>.call(.failure(error)) &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知代理属性，图片下载任务即将开始</span></span><br><span class="line">        delegate<span class="operator">?</span>.imageDownloader(<span class="keyword">self</span>, willDownloadImageForURL: url, with: request)</span><br><span class="line">        <span class="comment">// 调用resume方法开始下载图片</span></span><br><span class="line">        sessionTask.resume()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> downloadTask</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SessionDelegate类作为URLSession的代理，同时也负责管理我们创建的DownloadTask。SessionDelegate中有一个字典属性，该字典以下载任务的URL为key，DownloadTask为value。在上面我们分析的downloadImage用来创建图片下载任务的方法中可以看出来这个字典的作用。每次创建一个DownloadTask就把这个task放入SessionDelegate的字典中存储，等到下次需要使用到同一张图片的时候就不用重复创建下载任务。并且如果这个下载任务还未结束就又遇到了同一个URL的下载任务，甚至可以不用重复请求，直接使用上一次的请求结果。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add方法会重新创建一个SessionDataTask并存入字典中</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">add</span>(</span><br><span class="line">    <span class="keyword">_</span> <span class="params">dataTask</span>: <span class="type">URLSessionDataTask</span>,</span><br><span class="line">    <span class="params">url</span>: <span class="type">URL</span>,</span><br><span class="line">    <span class="params">callback</span>: <span class="type">SessionDataTask</span>.<span class="type">TaskCallback</span>) -&gt; <span class="type">DownloadTask</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock()</span><br><span class="line">    <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">	<span class="comment">// 由原生的URLSessionDataTask创建一个SessionDataTask包装</span></span><br><span class="line">    <span class="keyword">let</span> task <span class="operator">=</span> <span class="type">SessionDataTask</span>(task: dataTask)</span><br><span class="line">    <span class="comment">// 在这里为SessionDataTask添加某项CallbackTask被关闭时的回调</span></span><br><span class="line">    task.onCallbackCancelled.delegate(on: <span class="keyword">self</span>) &#123; [<span class="keyword">weak</span> task] (<span class="keyword">self</span>, value) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> task <span class="operator">=</span> task <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> (token, callback) <span class="operator">=</span> value</span><br><span class="line">        <span class="comment">// 当该回调被关闭的时候，通知该回调任务因为提前被主动关闭而失败</span></span><br><span class="line">        <span class="keyword">let</span> error <span class="operator">=</span> <span class="type">KingfisherError</span>.requestError(reason: .taskCancelled(task: task, token: token))</span><br><span class="line">        task.onTaskDone.call((.failure(error), [callback]))</span><br><span class="line">        <span class="comment">// 如果某个回调被关闭之后，SessionDataTask中没有其他的回调Task了，那么该SessionDataTask就没有用处了</span></span><br><span class="line">        <span class="comment">// 从SessionDelegate的字典中移除</span></span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>task.containsCallbacks &#123;</span><br><span class="line">            <span class="keyword">let</span> dataTask <span class="operator">=</span> task.task</span><br><span class="line">            <span class="keyword">self</span>.remove(dataTask)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将刚刚创建的SessionDataTask加入到SessionDelegate中的字典进行管理</span></span><br><span class="line">    <span class="keyword">let</span> token <span class="operator">=</span> task.addCallback(callback)</span><br><span class="line">    tasks[url] <span class="operator">=</span> task</span><br><span class="line">    <span class="keyword">return</span> <span class="type">DownloadTask</span>(sessionTask: task, cancelToken: token)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// append方法会将回调闭包的task添加到一个字典中已经存在的SessionDataTask当中</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">append</span>(</span><br><span class="line">    <span class="keyword">_</span> <span class="params">task</span>: <span class="type">SessionDataTask</span>,</span><br><span class="line">    <span class="params">url</span>: <span class="type">URL</span>,</span><br><span class="line">    <span class="params">callback</span>: <span class="type">SessionDataTask</span>.<span class="type">TaskCallback</span>) -&gt; <span class="type">DownloadTask</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> token <span class="operator">=</span> task.addCallback(callback)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">DownloadTask</span>(sessionTask: task, cancelToken: token)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将某一个URLSessionTask对应的SessionTask从字典中移除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">remove</span>(<span class="keyword">_</span> <span class="params">task</span>: <span class="type">URLSessionTask</span>) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> task.originalRequest<span class="operator">?</span>.url <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    lock.lock()</span><br><span class="line">    <span class="keyword">defer</span> &#123;lock.unlock()&#125;</span><br><span class="line">    tasks[url] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/06/13/Context%E5%88%9D%E8%AF%86%E3%80%81%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%BB%A5%E5%8F%8A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" rel="prev" title="Context初识、源码解析以及最佳实践">
      <i class="fa fa-chevron-left"></i> Context初识、源码解析以及最佳实践
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Source"><span class="nav-number">1.</span> <span class="nav-text">Source</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E5%8F%A3"><span class="nav-number">2.</span> <span class="nav-text">入口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KingfisherManager"><span class="nav-number">3.</span> <span class="nav-text">KingfisherManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">4.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%8A%A0%E8%BD%BD"><span class="nav-number">5.</span> <span class="nav-text">网络加载</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">六游</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liuyousama" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liuyousama" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/liuyousamae@gmail.com" title="E-Mail → liuyousamae@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备2021036102号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">六游</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
